package nl.kii.onyx

import com.onyx.persistence.ManagedEntity
import com.onyx.persistence.manager.PersistenceManager
import com.onyx.persistence.query.Query
import com.onyx.persistence.query.QueryCriteria
import com.onyx.persistence.query.QueryOrder
import com.onyx.persistence.update.AttributeUpdate
import java.util.AbstractList
import java.util.List
import nl.kii.onyx.annotations.Field
import nl.kii.onyx.annotations.Fluent
import nl.kii.onyx.annotations.MetaData

/**
 * Lets you build Onyx queries with static code, using the Data metadata
 * inner classes generated by the OnyxField and OnyxJoin active annotations.
 * To be ale to use this class with entities, they have to be annotated 
 * with OnyxField and OnyxJoin.
 * <p>
 * It is meant to be used together with the OnyxExtensions.
 * <p>
 * For example:
 * <p>
 * <pre>
 * // import the extensions
 * import static extension nl.kii.onyx.OnyxExtensions.*
 * // save an example entity
 * db.saveEntity(new User => [
 *    username = 'Jason'
 *    address = new Address => [
 *       streetName = 'Homeland'
 *    ]
 * ])
 * // perform the query
 * val results = db.query(User.Data)
 *    .where [ username == 'Jason' && address_streetName == 'Homeland' ]
 *    .order [ +id ]
 *    .lazyList
 * // print results
 * for(result : results) {
 *    println(result)
 * }
 * </pre>
 */
class TypedQueryBuilder<T extends ManagedEntity, M extends MetaData<T>> {
	
	val PersistenceManager session
	val Class<M> metaType
	val M metaTypeInstance

	List<Field<?>> fields
	QueryCriteria criteria
	List<AttributeUpdate<?>> updates
	List<QueryOrder> orders
	Integer firstRow
	Integer maxResults
	Integer pageNr
	IntegerRange range
	Object partition
	
	/**
	 * Create the builder. The metaType is the generated Data class inside the entity.
	 */
	new(PersistenceManager session, Class<M> metaType) {
		this.session = session
		this.metaType = metaType
		this.metaTypeInstance = metaType.newInstance
	}
	
	/** 
	 * Hydrate only the passed fields of the found entities.
	 * Pass each field inside a closure to get code completion
	 * of the possible fields.
	 * <p>
	 * <pre>Example: 
	 * db.query(User.Data)
	 *    .select([id], [username])
	 *    .list
	 */
	@Fluent
	def TypedQueryBuilder<T, M> select((M)=>Field<?>... fieldFns) {
		if(fields === null) fields = newLinkedList
		fields.addAll(fieldFns.map [ apply(metaTypeInstance) ])
		this
	}

	@Fluent
	def TypedQueryBuilder<T, M> where((M)=>QueryCriteria criteriaFn) {
		val newCriteria = criteriaFn.apply(metaTypeInstance)
		if(this.criteria === null) {
			this.criteria = newCriteria
		} else {
			this.criteria.and(newCriteria)
		}
		this
	}

	/**
	 * Order the found entities by the passed fields in the closure.
	 * It is ordered first by the first field, and if equal, then
	 * the second field, etc.
	 * <p>
	 * Pass each field inside a closure to get code completion
	 * of the possible fields.
	 * <p>
	 * <pre>Example:
	 * db.query(User.Data)
	 *    .order ([username], [email])
	 *    .list
	 */	
	@Fluent
	def TypedQueryBuilder<T, M> order((M)=>QueryOrder... orderFns) {
		if(orders === null) orders = newLinkedList
		orders.addAll(orderFns.map [ apply(metaTypeInstance) ])
		this 
	}
	
	/**
	 * Set multiple fields to update with a new value. Use the => operator overload
	 * from OnyxExtensions to set the new value.
	 * <p>
	 * Pass each field update inside a closure to get code completion
	 * of the possible fields.
	 * <p>
	 * <pre>Example:
	 * db.query(User.Data)
	 *    .set([ username => 'my new name' ], [ age => 30 ])
	 *    .where [ username == 'my old name' ]
	 *    .update
	 */	
	@Fluent
	def TypedQueryBuilder<T, M> set((M)=>AttributeUpdate<?>... updateFns) {
		if(updates === null) updates = newLinkedList
		updates.addAll(updateFns.map [ apply(metaTypeInstance) ])
		this
	}

	/**
	 * Skip the first [rowsToSkip] returned results.
	 */	
	@Fluent
	def TypedQueryBuilder<T, M> skip(int rowsToSkip) {
		this.firstRow = rowsToSkip
		this
	}
	
	/**
	 * Return at most [maxResults] entities.
	 */	
	@Fluent
	def TypedQueryBuilder<T, M> limit(int maxResults) {
		this.maxResults = maxResults
		this
	}

	/**
	 * Set a range of results. Starts counting at 1.
	 * <p>
	 * For example: range(4..6) only returns the 4th, 5th and 6th result. 
	 */	
	@Fluent
	def TypedQueryBuilder<T, M> range(IntegerRange range) {
		this.range = range
		this
	}

	/**
	 * Gets a specific page of the results. Starts counting at 1.
	 * <p>
	 * For example: page(2, 3) only returns the 4th, 5th and 6th result.
	 */	
	@Fluent
	def TypedQueryBuilder<T, M> page(int pageNr) {
		this.pageNr = pageNr
		this
	}
	
	/**
	 * Set the partition to query.
	 */
	@Fluent
	def TypedQueryBuilder<T, M> partition(Object partition) {
		this.partition = partition
		this
	}
	
	/** 
	 * Gets the query you have built so far.
	 * This also allows you to reuse a query for performance.
	 */	
	def build() {
		new Query(metaTypeInstance.entityType) => [
			if(fields !== null) it.selections = fields.map [ name ]
			if(criteria !== null) it.criteria = criteria
			if(updates !== null) it.updates = newLinkedList(updates) // hack around generic type warning
			if(orders !== null) it.queryOrders = orders
			if(maxResults !== null) it.maxResults = maxResults
			if(firstRow !== null) it.firstRow = firstRow
			if(partition !== null) it.partition = partition
			if(range !== null) {
				it.firstRow = it.firstRow + range.start - 1
				it.maxResults = Math.min(range.size, it.maxResults) 
			}
			if(pageNr !== null && maxResults !== null) {
				it.firstRow = ((pageNr - 1) * it.maxResults) + it.firstRow
			}
		]
	}

	/** Gets all results as a prefilled List */	
	def List<T> list() {
		session.executeQuery(build)
	}

	/** 
	 * Gets all results as a lazy list, meaning the values of the entities are not yet hydrated,
	 * but will be once they are requested.
	 */	
	def List<T> lazyList() {
		val query = session.executeLazyQuery(build)
		new AbstractList<T> {
			
			override get(int index) {
				query.get(index) as T
			}
			
			override size() {
				query.size
			}
			
		}
	}
	
	/** 
	 * Gets the first matching result, or null if there is no result. 
	 */
	def T first() {
		maxResults = 1
		session.executeQuery(build)?.head
	}

	/**
	 * Updates the entities that match the query with the updates
	 * that you specified with the .set method.
	 * @return the amount of updated entities
	 */
	def int update() {
		if(updates === null || updates.empty) throw new Exception('Cannot perform an update query without setting attribute updates. Did you forget to add a .set [ ] ?')
		session.executeUpdate(build)
	}

	/**
	 * Delete entities matching the query.
	 * @return the amount of removed entities
	 */
	def int delete() {
		session.executeDelete(build)
	}

}
